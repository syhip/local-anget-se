# 自动化需求变更与文档代码同步模块设计

## 1. 模块概述

本模块旨在实现根据输入的需求变更，自动更新相关的设计文档（遵循日本标准模板）和Java源代码，并自动生成相应的测试仕様書（日本标准）和部署流程说明。

## 2. 核心功能

- **需求变更解析**：接收并解析结构化的需求变更描述。
- **代码分析与修改**：利用AST（抽象语法树）分析Java代码，并根据变更需求修改代码结构和内容。
- **设计文档同步**：根据代码变更和需求描述，更新基本设计书和详细设计书（基于Markdown格式）。
- **测试仕様書生成**：根据代码和设计变更，自动生成符合日本标准的测试仕様書，包含测试用例。
- **部署流程生成**：根据变更内容，生成简化的部署步骤或更新说明。
- **双向追溯（初步）**：建立代码、设计文档、测试文档之间的初步关联。

## 3. 技术方案

### 3.1. 需求变更输入

- **初期方案**：采用结构化格式（如YAML或JSON）描述变更。例如：
  ```yaml
  change_type: add_feature
  feature_name: 用户积分查询
  description: "在用户中心添加积分查询接口和页面"
  affected_components:
    - UserCenterService.java
    - UserProfileController.java
    - user_profile.html
  design_doc_sections:
    - "基本设计书 - 機能一覧"
    - "詳細設計書 - UserCenterService"
  requirements:
    - "接口需返回用户当前积分和最近积分变更记录"
    - "页面需展示积分和记录列表"
  ```
- **远期方案**：集成LLM，支持自然语言输入的需求变更描述，并将其转换为内部结构化表示。

### 3.2. 代码处理 (Java)

- **AST解析**：使用Python库（如 `javalang` 或 `tree-sitter` 的Python绑定）解析Java源代码，生成AST。
- **代码分析**：遍历AST，定位需要修改的类、方法、字段等。
- **代码修改**：直接在AST上进行增、删、改操作。
- **代码生成**：将修改后的AST转换回Java源代码字符串。

### 3.3. 设计文档处理

- **文档格式**：优先处理由文档转换模块生成的Markdown格式的设计文档。
- **结构化表示**：将Markdown文档解析为内部结构化对象（如按章节、表格、列表组织的树状结构）。可以使用 `markdown` 库或 `mistune` 配合自定义解析逻辑。
- **内容定位**：根据需求变更中指定的章节或通过关键词/模式匹配，定位需要更新的部分。
- **内容更新**：修改结构化对象中的文本、表格内容等。
- **文档生成**：将更新后的结构化对象重新渲染为Markdown文档。
- **模板利用**：参考 `exia.co.jp` 等来源的模板结构（如機能一覧、画面一覧、テーブル定義書等），确保更新后的文档符合日本标准。

### 3.4. 测试仕様書生成

- **模板结构**：基于 `exia.co.jp` 和 `service.shiftinc.jp` 的模板，定义测试仕様書的结构（如测试项番、大項目、中項目、小項目、テスト条件、テスト手順、期待結果、実施結果等）。
- **测试用例生成**：
    - **基于规则**：根据变更类型（新增功能、修改逻辑、修复Bug）和代码结构（新增/修改的方法、类）生成基础测试用例（如边界值、等价类、路径覆盖）。
    - **基于LLM（可选）**：利用本地LLM根据功能描述和代码变更生成更自然的测试用例描述和步骤。
- **文档生成**：使用模板引擎（如Jinja2）或直接拼接字符串，将生成的测试用例填充到测试仕様書模板中，输出Markdown或Excel格式。

### 3.5. 部署流程生成

- **初步方案**：生成一个简单的文本文件或Markdown文件，列出本次变更涉及的主要文件（Java、配置文件、静态资源等），以及建议的部署步骤（如编译、打包、替换文件、重启服务等）。
- **远期方案**：根据项目配置（如Maven/Gradle构建文件、部署脚本模板）生成更具体的部署脚本或配置文件片段。

### 3.6. 映射与追溯

- **代码注释标记**：在Java代码的关键位置（如类、方法声明）添加特殊格式的注释，链接到设计文档的对应章节ID或需求ID。
  ```java
  /**
   * 用户服务实现
   * @designDoc section=DetailedDesign-UserService
   * @requirement REQ-001
   */
  public class UserCenterService { ... }
  ```
- **文档内容标记**：在设计文档的Markdown源文件中，使用类似ID或锚点链接到代码元素。
- **自动化维护**：在代码和文档更新时，尝试自动维护这些链接标记。

### 3.7. LLM集成（可选）

- **代码生成辅助**：根据设计描述生成方法框架或代码片段。
- **文档描述生成**：根据代码变更自动生成或更新设计文档中的描述性文字。
- **测试用例描述生成**：生成更自然的测试用例描述和预期结果。

## 4. 实现步骤

1.  **结构定义**：完成设计文档和测试仕様書的内部结构化表示定义。
2.  **解析器实现**：实现Java AST解析器和Markdown文档解析器。
3.  **核心变更逻辑**：开发根据结构化需求输入修改AST和文档结构的核心引擎。
4.  **生成器实现**：实现从修改后的AST生成Java代码，以及从修改后的文档结构生成Markdown文档。
5.  **测试仕様書生成**：实现测试用例生成逻辑和测试仕様書文档生成。
6.  **部署说明生成**：实现简单的部署步骤生成。
7.  **集成与测试**：将各部分集成，并进行单元测试和集成测试。

## 5. 风险与挑战

- **需求理解的准确性**：结构化输入简化了处理，但仍需精确定义。自然语言输入则更复杂。
- **代码与文档映射的复杂性**：完全自动化的精确映射非常困难，可能需要人工辅助或基于约定的标记。
- **代码修改的安全性**：自动修改代码存在引入新错误的风险，需要严格的测试和验证机制。
- **模板的泛化能力**：不同项目或团队的模板细节可能不同，需要设计可配置的模板处理机制。
- **LLM的离线性能与效果**：本地部署的开源LLM在代码理解和生成方面的能力可能有限。


